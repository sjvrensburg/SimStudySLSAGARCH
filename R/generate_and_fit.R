#' Data Generating Process
#'
#' Generates observations from the specified model with
#' hyperbolic secant distributed innovations.
#'
#' @param spec specification object create by `SLSAGARCH::specification`
#' @param param true parameters of the DGP
#' @param n sample size
#' @param R number of Monte Carlo replications
#' @param seed the seed for the rng
#' @param burn.in the burnin period
#' @param nthreads number of threads to use for parallel simulation
#'
#' @return An n x R matrix of simulated observations.
#' @export
#'
#' @examples
#' # Create the model specification
#' spec <- specification(type = "S")
#' # True parameter values
#' param0 <- c(h0 = 1, omega = 0.1, alpha = 0.075, beta = 0.85, lambda = 1, rho = 0.75)
#' #   Set the initial conditional volatility equal to the unconditional volatility.
#' param0[1] <- SLSAGARCH:::unconditional.specification(spec, param0)
#' # Simulate 10000 series, each of length 500
#' dgp(spec, param0, n = 500, R = 10000, seed = 20240127, nthreads = 10L)
dgp <- function(spec, param, n, R, seed, burn.in = 25000L, nthreads = 4L) {
  # Simulate the innovations
  z <- prhs(n = n + burn.in, m = R, seed = seed,
            numThreads = nthreads)

  # Extract the parameters
  theta <- SLSAGARCH:::expand_par(spec = spec, x = param)
  h0 <- SLSAGARCH:::unconditional.specification(spec, param)
  theta <- theta[-1]

  # Pass the innovations to simulate
  ngrain <- ceiling(R / nthreads)
  res <- switch(
    spec$type,
    "a" = SLSAGARCH:::lstParallelGenerate(
      dblH0 = h0, matZ = z, vecParam = theta,
      intModel = 0L, intGrainSize = ngrain,
      intNumThreads = nthreads),
    "s" = SLSAGARCH:::lstParallelGenerate(
      dblH0 = h0, matZ = z, vecParam = theta,
      intModel = 1L, intGrainSize = ngrain,
      intNumThreads = nthreads)
  )

  # Extract the data
  res$y[-1 * 1:burn.in, ]
}

#' Fit Specified Model to Simulated Data
#'
#' This is a simple wrapper around `SLSAGARCH::estimate` that
#' produces a tibble suitably for further analysis.
#'
#' @param spec specification object create by `SLSAGARCH::specification`
#' @param param true parameters of the DGP
#' @param y simulated observations
#' @param se_type method for calculating the standard errors
#' @param ... additional arguments passed to `SLSAGARCH::estimate`
#'
#' @return A tibble with estimates
#' @export
#'
#' @examples
#' # Create the model specification
#' spec <- specification(type = "S")
#' # True parameter values
#' param0 <- c(h0 = 1, omega = 0.1, alpha = 0.075, beta = 0.85, lambda = 1, rho = 0.75)
#' #   Set the initial conditional volatility equal to the unconditional volatility.
#' param0[1] <- SLSAGARCH:::unconditional.specification(spec, param0)
#' # Simulate 10000 series, each of length 500
#' Y <- dgp(spec, param0, n = 500, R = 10000, seed = 20240127, nthreads = 10L)
#' fit(spec, param0, Y[, 1])
fit <- function(spec, param, y, se_type = "QMLE", ...) {
  status <- rep(-1, spec$k)
  elapsed <- parhat <- se <- rep(NA, spec$k)

  try(expr = {
    # Estimate the model
    est_model <- SLSAGARCH::estimate(spec, x = y, ...)

    # Status
    status <- rep(est_model$status, spec$k)
    elapsed <- rep(est_model$elapsed, spec$k)

    # Extract the coefficients and standard errors
    parhat <- SLSAGARCH:::coef.fitted(est_model)
    se <- SLSAGARCH:::vcov.fitted(est_model, type = se_type) |>
      diag() |>
      sqrt()
  })

  # Create the data frame
  dplyr::tibble(
    status = status, par = spec$names,
    true = param, est = parhat, se = se,
    elapsed = elapsed) |>
    dplyr::filter(par != "h0")
}

#' Fit Many
#'
#' @param spec specification object create by `SLSAGARCH::specification`
#' @param param true parameters of the DGP
#' @param ymat matrix of simulated observations
#' @param se_type method for calculating the standard errors
#' @param label a label used to identify the simulation
#' @param strategy evaluation function (or name of it) to use for resolving a future. If NULL, then the current strategy is returned.
#' @param nchunks the number of realisations to pass to each thread
#' @param .errorhandling specifies how a task evaluation error should be handled. If the value is "stop", then execution will be stopped via the stop function if an error occurs. If the value is "remove", the result for that task will not be returned, or passed to the .combine function. If it is "pass", then the error object generated by task evaluation will be included with the rest of the results. It is assumed that the combine function (if specified) will be able to deal with the error object. The default value is "stop".
#' @param verbose logical flag enabling verbose messages
#' @param ...
#'
#' @return a dataframe
#'
#' @details
#' This function creates a `progressor` that signals progress updates. The user
#' can run the function inside of a `with_progress` function to show a progress
#' bar.
#'
#' @importFrom doFuture %dofuture%
#' @importFrom foreach foreach
#' @importFrom foreach %do%
#' @export
#'
#' @examples
#' # Create the model specification
#' spec <- specification(type = "S")
#' # True parameter values
#' param0 <- c(h0 = 1, omega = 0.1, alpha = 0.075, beta = 0.85, lambda = 1, rho = 0.75)
#' #   Set the initial conditional volatility equal to the unconditional volatility.
#' param0[1] <- SLSAGARCH:::unconditional.specification(spec, param0)
#' # Simulate 10000 series, each of length 500
#' Y <- dgp(spec, param0, n = 500, R = 10000, seed = 20240127, nthreads = 10L)
#' fit_many(spec, param0, Y, strategy = "multisession", nchunks = 100)
#' # if you want to see a progress bar...
#' progressr::with_progress(fit_many(spec, param0, Y, strategy = "multisession", nchunks = 100))
fit_many <- function(spec, param, ymat, se_type = "QMLE",
                     label = sim_lab(
                       n = nrow(ymat), lambda = param["lambda"],
                       rho = param["rho"]),
                     strategy = "sequential", nchunks = 100,
                     .errorhandling = "stop", verbose = TRUE, ...) {
  if (!is.null(strategy)) {
    switch(strategy,
           "sequential" = future::plan(strategy = future::sequential),
           "multisession" = future::plan(strategy = future::multisession),
           "multicore" = future::plan(strategy = future::multicore)
    )
  }
  chunks <- chunk(1:ncol(ymat), nchunks)
  p <- progressr::progressor(steps = length(chunks))
  out <- foreach::foreach(
    i = 1:nchunks, .combine = "rbind", .inorder = FALSE, .verbose = verbose,
    .options.future = list(seed = TRUE), .errorhandling = .errorhandling
  ) %dofuture% {
    idx <- chunks[[i]]
    ymat_i <- ymat[, idx]
    out_i <- foreach::foreach(
      j = 1:ncol(ymat_i), .combine = "rbind", .inorder = FALSE,
      .options.future = list(seed = TRUE)) %do% {
        res <- fit(spec, param, ymat_i[, j], se_type, ...)
        res$sample <- idx[j]
        res$nobs <- nrow(ymat_i)
        res
      }
    p(message = sprintf("Completed chunk %d", i))
    out_i
  }
  cbind("Simulation" = label, out)
}
